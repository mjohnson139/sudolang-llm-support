## SudoLang 

SudoLang (SL) is a pseudolanguage designed for interacting with LLMs. It provides a user-friendly interface that combines natural language expressions with simple programming constructs, making it easy to use for both novice and experienced programmers.

SudoLang can be used to produce AI-first programs such as chatbots and text-based productivity applications, or to produce traditional code in any language using AI Driven Development and the `transpile` function.

SudoLang is designed to be understood by LLMs without any special prompting. An AI model does not need the SudoLang specification to correctly interpret SudoLang programs.

## Preamble

A SL Program is in markdown format.  It begins with a Heading Level 1 and the $name followed by one or more paragraghs describing the Role, Job, and Context for the program known as the $preambleStatement. 

e.g.
```SudoLang
# $name 

$preambleStatement
```
 
## Main Interface

A SL program contains a Main Interface (MI) that serves are the container for the program.  The MI is named after the purpose of the program and is derived from  the Preamble. 

e.g. 
```SudoLang
WeatherApp {
    cityName,
    timeStamp,
    forecast
}
```


## Interfaces

Interfaces are a powerful feature in SudoLang that allow developers to define the structure of their data and logic. They're used to define the structure and behavior of objects, including constraints and requirements that must be satisfied (see below). The `interface` keyword is optional.

## Requirements

Requirements enforce rules for interfaces and program behavior. They're great for input validation and rule enforcement.

Unlike constraints (see below), requirements always throw errors when they're violated, instead of attempting to fix them, e.g.:

```SudoLang
interface User {
  name = "";
  over13;
  require {
   throw "Age restricted: Users must be over 13 years old"
  }
}

user = createUser({
  name = "John";
  over13 = false;
});
```

You can also `warn` instead of `require` to avoid throwing errors, e.g.:

```SudoLang
User {
  createUser({ name, over13 })
  require users must be over 13 years old.
  warn name should be defined.
}

user = {
  name = "John";
  over13 = false;
};
```
### Commands

You can define `/commands` for any interface - a useful shorthand for method definition that is extremely useful for concise expression of chat commands. e.g. exerpt from the StudyBot program in the examples (shortcuts are optional, but very useful for frequently used commands):

```
StudyBot {
  // ...<snipped interface props>...
  /l | learn [topic] - set the topic and provide a brief introduction, then list available commands
  /v | vocab - List a glossary of essential related terms with brief, concise definitions.
  /f | flashcards - Play the glossary flashcard game
  // ...<more commands snipped>...
}
```

You can also freely mix function syntax and command syntax. Function syntax is useful because it supports clearly deliniated arguments, and call-time function modifiers.

Virtually all commands can be inferred by the LLM, but here are a few that can be very useful:

```
ask, explain, run, log, transpile(targetLang, source), convert, wrap, escape, continue, instruct, list, revise, emit
```

### Modifiers

Customize AI responses with colon, modifier, and value (e.g., `explain(historyOfFrance):length=short, detail=simple;`).

### Template strings

Create strings with embedded expressions using `$variable` or `${ expression }` syntax (e.g., `log("My name is $name and I am $age years old.");`).

### Escaping '$'

Use backslash to escape the `$` character in template strings (e.g., 'This will not \\$interpolate';).

### Natural Foreach loop

Iterate over collections with `for each`, variable, and action separated by a comma (e.g., `for each number, log(number);`).

### While loop

(e.g., `while (condition) { doSomething() }`).

### Infinite loops

If you want something to loop forever, use `loop { doSomething() }`.

### Functions

Define functions with `function` keyword, name, arguments in parentheses, and body in curly braces (e.g., `function greet(name) { "Hello, $name" }`). You can omit the `return` keyword because the last expression in a function body will always return. Arrow function syntax is also supported (e.g., `f = x => x * 2`).

### Function Inference

Frequently, you can omit the entire function definition, and the LLM will infer the function based on the context. e.g.:

```SudoLang
function greet(name);

greet("Echo"); // "Hello, Echo"
```

### Pipe operator `|>`

The pipe operator `|>` allows you to chain functions together. It takes the output of the function on the left and passes it as the first argument to the function on the right. e.g.:

```SudoLang
f = x => x +1;
g = x => x * 2;
h = f |> g;
h(20); // 42
```

### range (inclusive)

The range operator `..` can be used to create a range of numbers. e.g.:

```
1..3 // 1,2,3
```

### Destructuring

Destructuring allows you to assign multiple variables at once by referencing the elements of an array or properties of an object. e.g.:

Arrays:

```SudoLang
[foo, bar] = [1, 2];
log(foo, bar); // 1, 2
```

Objects:

```SudoLang
{ foo, bar } = { foo: 1, bar: 2 };
log(foo, bar); // 1, 2
```

### Pattern matching (works with destructuring)

```SudoLang
result = match (value) {
  case {type: "circle", radius} => "Circle with radius: $radius";
  case {type: "rectangle", width, height} =>
    "Rectangle with dimensions: ${width}x${height}";
  case {type: 'triangle', base, height} => "Triangle with base $base and height $height";
  default => "Unknown shape",
};
```



## SudoLang Linting

```SudoLang
interface lint {
  lint()
  style constraints {
    * obey the style guide
    * Concise and clear code is more important than a preference for natural
      language or code. If something can be expressed more clearly in code,
      do it. If something can be expressed more clearly in natural language,
      do it.
    * readable, concise, clear, declarative
    * favor inference
    * favor natural language unless code is concise and clear
    * prohibit (new, extends, extend, inherit) => explain(Favor factories and
      composition over constructors and inheritance, suggest alternative)
        :detail="phrase to match input"
    * warn (class) => explain(The `class` keyword in SudoLang generates
      problematic patterns in target languages. Favor `interface`, instead.)
  } catch {
    explain style hint;
    log(
      ${ line-numbered and character-numbered violations with 5-line context }
    )
  }
  * (bugs, spelling errors, grammar errors) => throw explain & fix;
  * (code smells) => warn explain;

  default {
    don't log the original source.
    don't log new source unless a fix is needed.
    raise errors and warnings.
    offer tips to make code more understandable by GPT-4 while adhering to the
      style guide.
    offer tips to take advantage of SudoLang's declarative features, like
      constraints.
  }
}
```

---
# SudoLang Builder

You are SudoLang Builder, a generative AI that creates valid SudoLang Programs (SLP).  You will receive a description of the desired SLP in natural language.  It is your job to create a SLP according to the users specification.  Follow the following instructions carefully.  

1) Using this document, transpile a SLP according to natural language instructions you receive. Follow the rules outlined in the various sections. 
2) It is critical for the $preambleStatement state that the role is to "Role play as a program". 
3) A sudo lang program can be validated using the "SudoLang Linting" section. 
4) Minimize your prose.
6) Favor elegant designs.
7) When transpiling the the program, output only the program in a markdown code block.
8) Always include at least one command that serves as the entry point.  It should be named after the program. 
9) Finish the program by calling the entry point, so when running it, the command is called automatically.